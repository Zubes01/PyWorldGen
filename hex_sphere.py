import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from math import sqrt
from collections import defaultdict
import opensimplex
import random
import time
import pickle
import os

class SimulatedGlobe:
    # Creates a sphere tiled with hexagons (and 12 pentagons) for world generation
    # The globe is made up of WorldHexagons, each with a center and vertices in 3D space
    # The hexagons are generated by creating an icosphere and then taking the dual
    # of the triangular mesh to create hexagons and pentagons
    # Each WorldHexagon can have properties like Perlin noise value and color assigned later
    def __init__(self, recursion_level):
        self.recursion_level = recursion_level
        self.world_hexagons = []
        self.noise_4d_val = np.random.uniform(0, 1000)  # Random value for 4D noise slice
        self.create_world_hexagons()

    def create_world_hexagons(self):
        """
        Create WorldHexagon objects for each hex/pentagon on the sphere.
        """

        def create_icosphere():
            """
            Creates a geodesic sphere from an icosahedron.
            
            Args:
            recursion_level: The number of times to subdivide the faces.
            
            Returns:
            A tuple containing two numpy arrays: vertices and faces.
            """
            phi = (1.0 + sqrt(5.0)) / 2.0
            
            vertices = np.array([
                [-1, phi, 0], [1, phi, 0], [-1, -phi, 0], [1, -phi, 0],
                [0, -1, phi], [0, 1, phi], [0, -1, -phi], [0, 1, -phi],
                [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]
            ])
            vertices /= np.linalg.norm(vertices, axis=1)[:, np.newaxis]

            faces = np.array([
                [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
            ])

            # Memoization dictionary for middle points
            middle_point_cache = {}

            def get_middle_point(p1, p2):
                nonlocal vertices
                
                # Sort points to ensure a consistent key
                smaller_index, larger_index = min(p1, p2), max(p1, p2)
                key = (smaller_index, larger_index)

                if key in middle_point_cache:
                    return middle_point_cache[key]
                else:
                    # Calculate midpoint and normalize
                    midpoint = (vertices[p1] + vertices[p2]) / 2.0
                    midpoint /= np.linalg.norm(midpoint)
                    
                    # Add to vertices and cache index
                    vertices = np.vstack([vertices, midpoint])
                    new_index = len(vertices) - 1
                    middle_point_cache[key] = new_index
                    return new_index

            for _ in range(self.recursion_level):
                new_faces = []
                for tri in faces:
                    v1, v2, v3 = tri
                    a = get_middle_point(v1, v2)
                    b = get_middle_point(v2, v3)
                    c = get_middle_point(v3, v1)
                    
                    new_faces.append([v1, a, c])
                    new_faces.append([v2, b, a])
                    new_faces.append([v3, c, b])
                    new_faces.append([a, b, c])
                faces = np.array(new_faces)
                
            return vertices, faces

        def icosphere_to_hexsphere(vertices, faces):
            """
            Convert an icosphere into a hexagon-tiled sphere (with 12 pentagons).
            
            The dual of the icosphere subdivision creates hexagons and pentagons.
            Each vertex in the original mesh becomes the center of a hex/pentagon,
            and we create faces by connecting the centroids of adjacent triangles.
            
            Args:
            vertices: Vertex array from icosphere
            faces: Face array from icosphere
            
            Returns:
            hex_faces: List of vertex indices forming each hex/pentagon
            """
            # Find which faces are adjacent to each vertex
            vertex_to_faces = defaultdict(list)
            for face_idx, face in enumerate(faces):
                for vertex in face:
                    vertex_to_faces[vertex].append(face_idx)
            
            # Calculate face centroids (these become the vertices of the hex tiles)
            face_centroids = []
            for face in faces:
                centroid = np.mean(vertices[face], axis=0)
                centroid /= np.linalg.norm(centroid)  # Project back to sphere
                face_centroids.append(centroid)
            face_centroids = np.array(face_centroids)
            
            # For each vertex in the original mesh, create a hex/pentagon
            # by ordering the centroids of adjacent faces
            hex_faces = []
            
            for vertex_idx in range(len(vertices)):
                adjacent_faces = vertex_to_faces[vertex_idx]
                
                # Order the adjacent face centroids in circular order
                # We do this by sorting by angle around the vertex
                center = vertices[vertex_idx]
                
                # Create a local coordinate system
                # Use the first adjacent face centroid to define a reference direction
                ref_vec = face_centroids[adjacent_faces[0]] - center
                ref_vec /= np.linalg.norm(ref_vec)
                
                # Create perpendicular vector for angle calculation
                normal = center / np.linalg.norm(center)
                tangent = ref_vec - np.dot(ref_vec, normal) * normal
                tangent /= np.linalg.norm(tangent)
                bitangent = np.cross(normal, tangent)
                
                # Calculate angles for each adjacent face centroid
                angles = []
                for face_idx in adjacent_faces:
                    vec = face_centroids[face_idx] - center
                    vec /= np.linalg.norm(vec)
                    # Project onto tangent plane
                    vec_proj = vec - np.dot(vec, normal) * normal
                    vec_proj /= np.linalg.norm(vec_proj)
                    
                    # Calculate angle
                    x = np.dot(vec_proj, tangent)
                    y = np.dot(vec_proj, bitangent)
                    angle = np.arctan2(y, x)
                    angles.append((angle, face_idx))
                
                # Sort by angle
                angles.sort()
                ordered_faces = [face_idx for _, face_idx in angles]
                
                hex_faces.append(ordered_faces)
            
            return hex_faces, face_centroids

        # Create the cache directory if it doesn't exist
        os.makedirs('./.cache', exist_ok=True)

        # Check if cached hexagons exist
        try:
            with open(f'./.cache/world_hexagons_{self.recursion_level}.pkl', 'rb') as f:
                self.world_hexagons = pickle.load(f)
                print("\tLoaded cached world hexagons.")
                return
        except FileNotFoundError:
            print("\tNo cached world hexagons found, generating new ones.")

        vertices, faces = create_icosphere()
        hex_faces, face_centroids = icosphere_to_hexsphere(vertices, faces)
        for hf in hex_faces:
            poly_verts = face_centroids[hf]
            self.world_hexagons.append(WorldHexagon(np.mean(poly_verts, axis=0), poly_verts))

        # Save the world hexagons to a file for faster loading next time
        with open(f'./.cache/world_hexagons_{self.recursion_level}.pkl', 'wb') as f:
            pickle.dump(self.world_hexagons, f)


    def map_perlin_noise(self, scale=3):
        """
        Map 4D Perlin noise values to each hexagon for terrain generation.
        """
        noise_gen = opensimplex.OpenSimplex(seed=random.randint(0, 10000))
        for hexagon in self.world_hexagons:
            x, y, z = hexagon.center
            # Scale coordinates for noise
            # Note: using 4D noise with a fixed w value to get a 3D slice for randomness
            value = noise_gen.noise4(x * scale, y * scale, z * scale, self.noise_4d_val)
            hexagon.perlin_value = value

    def assign_perlin_terrain_colors(self, water_threshold=0.5, beach_threshold=0.52, land_threshold=0.73, mountain_threshold=0.81, water_low_color=(0, 0, 0.2), water_high_color=(0, 0, 1), beach_color=(0.86, 0.80, 0.20), land_low_color=(0, 0.4, 0), land_high_color=(0, 1, 0), mountain_low_color=(0.7, 0.7, 0.7), mountain_high_color=(0.8, 0.8, 0.8), snow_color=(1, 1, 1)):
        """
        Assign terrain colors to each hexagon based on Perlin noise values.
        """
        for hexagon in self.world_hexagons:
            if hexagon.perlin_value is None:
                raise ValueError("Perlin noise values not mapped. Call map_perlin_noise() first.")
            # noise value ranges from -1 to 1
            # Normalize to 0-1
            normalized_value = (hexagon.perlin_value + 1) / 2
            if normalized_value < water_threshold:
                # Blue value should move from water_low_color to water_high_color based on normalized_value
                t = normalized_value / water_threshold
                hexagon.color = tuple(np.array(water_low_color) * (1 - t) + np.array(water_high_color) * t)
            elif normalized_value < beach_threshold:
                hexagon.color = beach_color
            elif normalized_value < land_threshold:
                # Green value should move from land_low_color to land_high_color based on normalized_value
                t = (normalized_value - water_threshold) / (land_threshold - water_threshold)
                hexagon.color = tuple(np.array(land_low_color) * (1 - t) + np.array(land_high_color) * t)
            elif normalized_value < mountain_threshold:
                # Gray value should move from mountain_low_color to mountain_high_color based on normalized_value
                t = (normalized_value - land_threshold) / (1 - land_threshold)
                hexagon.color = tuple(np.array(mountain_low_color) * (1 - t) + np.array(mountain_high_color) * t)
            else:
                # White color for snow
                hexagon.color = snow_color

    def populate_neighbor_lists(self):
        """
        Populate the neighbor lists for each hexagon.
        """
        # Create a mapping from vertex (as a tuple) to hexagons that share it
        vertex_to_hexagons = defaultdict(list)
        for hexagon in self.world_hexagons:
            for vertex in hexagon.vertices:
                vertex_key = tuple(np.round(vertex, decimals=6))  # Round to avoid floating point issues
                vertex_to_hexagons[vertex_key].append(hexagon)

        # For each hexagon, find neighbors by looking up shared vertices
        for hexagon in self.world_hexagons:
            neighbor_set = set()
            for vertex in hexagon.vertices:
                vertex_key = tuple(np.round(vertex, decimals=6))
                for neighbor in vertex_to_hexagons[vertex_key]:
                    if neighbor is not hexagon:
                        neighbor_set.add(neighbor)
            hexagon.neighbors = list(neighbor_set)

    def paint_random_and_neighbors_red(self):
        """
        For testing: Paint a random hexagon and its neighbors red.
        """
        random_hex = random.choice(self.world_hexagons)
        random_hex.color = (1, 0, 0)  # Red
        for neighbor in random_hex.neighbors:
            neighbor.color = (1, 0, 0)  # Red

    def plot_equirectangular(self):
        # Simple equirectangular projection for testing
        fig, ax = plt.subplots(figsize=(10, 5))
        for hexagon in self.world_hexagons:
            # Convert 3D vertices to 2D (longitude, latitude)
            lon_lat = []
            for v in hexagon.vertices:
                x, y, z = v
                lon = np.arctan2(y, x)
                lat = np.arcsin(z / np.linalg.norm(v))
                lon_lat.append((lon, lat))

            # Unwrap longitudes to avoid stretching across the map edge
            lons = np.array([ll[0] for ll in lon_lat])
            lats = np.array([ll[1] for ll in lon_lat])
            # Find jumps in longitude
            lon_diffs = np.diff(lons)
            if np.any(np.abs(lon_diffs) > np.pi):
                # If a jump > pi is found, unwrap longitudes
                lons_unwrapped = lons.copy()
                for i in range(1, len(lons_unwrapped)):
                    diff = lons_unwrapped[i] - lons_unwrapped[i-1]
                    if diff > np.pi:
                        lons_unwrapped[i:] -= 2 * np.pi
                    elif diff < -np.pi:
                        lons_unwrapped[i:] += 2 * np.pi
                lon_lat = list(zip(lons_unwrapped, lats))

            polygon = plt.Polygon(lon_lat, edgecolor=None, alpha=0.5, facecolor=hexagon.color)
            ax.add_patch(polygon)

        ax.set_xlim(-np.pi - 0.3, np.pi + 0.3) # Add some padding for longitudes that were unwrapped
        ax.set_ylim(-np.pi/2, np.pi/2)
        ax.set_aspect('equal')
        plt.show()

    def plot_sphere(self):
        """
        Visualize the hexagon-tiled sphere.
        """
        fig = plt.figure(figsize=(5, 5))
        
        # Hex-tiled sphere
        ax = fig.add_subplot(projection='3d')
        hex_polys = []
        colors = []
        for hexagon in self.world_hexagons:
            poly_verts = hexagon.vertices
            hex_polys.append(poly_verts)
            colors.append(hexagon.color)

        poly = Poly3DCollection(hex_polys, facecolors=colors, linewidths=1, edgecolors='black', alpha=0.9)
        ax.add_collection3d(poly)
        
        max_range = 1.2
        ax.set_xlim(-max_range, max_range)
        ax.set_ylim(-max_range, max_range)
        ax.set_zlim(-max_range, max_range)
        ax.set_box_aspect([1, 1, 1])
        
        plt.tight_layout()
        plt.show()

    def print_geometry_statistics(self):
        """
        Print statistics about the hexagonal grid.
        """
        num_hexagons = len(self.world_hexagons)
        num_pentagons = sum(1 for h in self.world_hexagons if len(h.vertices) == 5)
        num_hexagons_only = num_hexagons - num_pentagons

        max_x_coord_for_center_of_hexagon = max(h.center[0] for h in self.world_hexagons)
        min_x_coord_for_center_of_hexagon = min(h.center[0] for h in self.world_hexagons)
        max_y_coord_for_center_of_hexagon = max(h.center[1] for h in self.world_hexagons)
        min_y_coord_for_center_of_hexagon = min(h.center[1] for h in self.world_hexagons)
        max_z_coord_for_center_of_hexagon = max(h.center[2] for h in self.world_hexagons)
        min_z_coord_for_center_of_hexagon = min(h.center[2] for h in self.world_hexagons)
        
        print(f"Total hexagons (including pentagons): {num_hexagons}")
        print(f"Number of pentagons: {num_pentagons}")
        print(f"Number of hexagons: {num_hexagons_only}")
        print(f"Max X coord for center of hexagon: {max_x_coord_for_center_of_hexagon}")
        print(f"Min X coord for center of hexagon: {min_x_coord_for_center_of_hexagon}")
        print(f"Max Y coord for center of hexagon: {max_y_coord_for_center_of_hexagon}")
        print(f"Min Y coord for center of hexagon: {min_y_coord_for_center_of_hexagon}")
        print(f"Max Z coord for center of hexagon: {max_z_coord_for_center_of_hexagon}")
        print(f"Min Z coord for center of hexagon: {min_z_coord_for_center_of_hexagon}")

class WorldHexagon:
    def __init__(self, center, vertices):
        self.center = center  # 3D coordinates on the sphere
        self.vertices = vertices  # List of 3D vertex coordinates
        self.perlin_value = None  # To be assigned later
        self.color = None  # To be assigned later
        self.neighbors = []  # List of neighboring WorldHexagons

def main():
    print("Creating simulated globe...")
    start_time = time.time()
    globe = SimulatedGlobe(recursion_level=6)
    end_time = time.time()
    print(f"Globe creation took {end_time - start_time:.2f} seconds.")

    print("Mapping perlin noise...")
    start_time = time.time()
    globe.map_perlin_noise()
    end_time = time.time()
    print(f"Perlin noise mapping took {end_time - start_time:.2f} seconds.")

    print("Assigning terrain colors...")
    start_time = time.time()
    globe.assign_perlin_terrain_colors()
    end_time = time.time()
    print(f"Terrain color assignment took {end_time - start_time:.2f} seconds.")

    print("Populating neighbor lists...")
    start_time = time.time()
    globe.populate_neighbor_lists()
    end_time = time.time()
    print(f"Neighbor list population took {end_time - start_time:.2f} seconds.")

    print("Painting a random hexagon and its neighbors red...")
    start_time = time.time()
    globe.paint_random_and_neighbors_red()  # For testing neighbor functionality
    end_time = time.time()
    print(f"Painting took {end_time - start_time:.2f} seconds.")

    print("Printing geometry statistics...")
    start_time = time.time()
    globe.print_geometry_statistics()
    end_time = time.time()
    print(f"Geometry statistics took {end_time - start_time:.2f} seconds.")

    print("Plotting the globe...")
    globe.plot_sphere()
    end_time = time.time()
    print(f"Globe plotting took {end_time - start_time:.2f} seconds.")

    print("Plotting equirectangular projection...")
    start_time = time.time()
    globe.plot_equirectangular()
    end_time = time.time()
    print(f"Equirectangular projection plotting took {end_time - start_time:.2f} seconds.")

if __name__ == '__main__':
    main()