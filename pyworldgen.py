"""
Imports
"""
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from math import sqrt
from collections import defaultdict
import opensimplex
import random
import time
import pickle
import os
from tqdm import tqdm
from scipy.spatial import SphericalVoronoi

"""
CONSTANTS
"""
# Globe generation parameters
GLOBE_RECURSION_LEVEL = 6 # Level of recursion for icosphere generation
NOISE_SCALE = 2  # Scale for noise mapping
NUM_OCTAVES = 4  # Number of octaves for noise generation

# Tectonic plate parameters
NUM_TECTONIC_PLATES = 15 # Number of tectonic plates to create
OCEANIC_PLATE_RATIO = 0.7  # Ratio of oceanic plates to total plates
OCEANIC_PLATE_AVG_HEIGHT = 0.33  # Average height for oceanic plates
CONTINENTAL_PLATE_AVG_HEIGHT = 0.66  # Average height for continental plates

# Terrain coloring thresholds
WATER_THRESHOLD = 0.5  # Height threshold for ocean color
BEACH_THRESHOLD = 0.52  # Height threshold for beach color
LAND_THRESHOLD = 0.73  # Height threshold for land color
MOUNTAIN_THRESHOLD = 0.81  # Height threshold for mountain color

# Terrain colors
WATER_LOW_COLOR = (0, 0, 0.2)
WATER_HIGH_COLOR = (0, 0, 1)
BEACH_COLOR = (0.86, 0.80, 0.20)
LAND_LOW_COLOR = (0, 0.4, 0)
LAND_HIGH_COLOR = (0, 1, 0)
MOUNTAIN_LOW_COLOR = (0.7, 0.7, 0.7)
MOUNTAIN_HIGH_COLOR = (0.8, 0.8, 0.8)
SNOW_COLOR = (1, 1, 1)

"""
Classes
"""
class SimulatedGlobe:
    """
    Creates a sphere tiled with tiles (hexagons and 12 pentagons) for world generation
    The globe is made up of WorldTiles, each with a center and vertices in 3D space
    The tile locations are generated by creating an icosphere and then taking the dual
    of the triangular mesh to create tiles (hexagons and pentagons)
    """

    """
    Standard functions
    """
    def __init__(self, recursion_level, use_cache=True):
        self.recursion_level = recursion_level
        self.use_cache = use_cache
        self.world_tiles = [] # list of all WorldTile objects on the sphere
        self.tectonic_plates = [] # list of TectonicPlate objects
        self.plate_boundaries = [] # list of PlateBoundary objects
        self.noise_4d_val = np.random.uniform(0, 1000)  # Random value for 4D noise slice
        self.noise_4d_val_2 = np.random.uniform(0, 1000)  # Second random value for 4D noise slice
        self.create_world_tiles(recursion_level)

    """
    Generating the tiles
    """
    def create_world_tiles(self, rec_lvl):
        """
        Create WorldTile objects for each tile (hex/pentagon) on the sphere.
        """

        def create_icosphere(recursion_level):
            """
            Creates a geodesic sphere from an icosahedron.
            
            Args:
            recursion_level: The number of times to subdivide the faces.
            
            Returns:
            A tuple containing two numpy arrays: vertices and faces.
            """
            phi = (1.0 + sqrt(5.0)) / 2.0
            
            vertices = np.array([
                [-1, phi, 0], [1, phi, 0], [-1, -phi, 0], [1, -phi, 0],
                [0, -1, phi], [0, 1, phi], [0, -1, -phi], [0, 1, -phi],
                [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]
            ])
            vertices /= np.linalg.norm(vertices, axis=1)[:, np.newaxis]

            faces = np.array([
                [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
            ])

            # Memoization dictionary for middle points
            middle_point_cache = {}

            def get_middle_point(p1, p2):
                nonlocal vertices
                
                # Sort points to ensure a consistent key
                smaller_index, larger_index = min(p1, p2), max(p1, p2)
                key = (smaller_index, larger_index)

                if key in middle_point_cache:
                    return middle_point_cache[key]
                else:
                    # Calculate midpoint and normalize
                    midpoint = (vertices[p1] + vertices[p2]) / 2.0
                    midpoint /= np.linalg.norm(midpoint)
                    
                    # Add to vertices and cache index
                    vertices = np.vstack([vertices, midpoint])
                    new_index = len(vertices) - 1
                    middle_point_cache[key] = new_index
                    return new_index

            for _ in tqdm(range(recursion_level), position=0, desc="Subdividing faces"):
                new_faces = []
                for tri in tqdm(faces, position=1, leave=False):
                    v1, v2, v3 = tri
                    a = get_middle_point(v1, v2)
                    b = get_middle_point(v2, v3)
                    c = get_middle_point(v3, v1)
                    
                    new_faces.append([v1, a, c])
                    new_faces.append([v2, b, a])
                    new_faces.append([v3, c, b])
                    new_faces.append([a, b, c])
                faces = np.array(new_faces)
                
            return vertices, faces

        def icosphere_to_hexsphere(vertices, faces):
            """
            Convert an icosphere into a hexagon-tiled sphere (with 12 pentagons).
            
            The dual of the icosphere subdivision creates hexagons and pentagons.
            Each vertex in the original mesh becomes the center of a hex/pentagon,
            and we create faces by connecting the centroids of adjacent triangles.
            
            Args:
            vertices: Vertex array from icosphere
            faces: Face array from icosphere
            
            Returns:
            hex_faces: List of vertex indices forming each hex/pentagon
            """
            # Find which faces are adjacent to each vertex
            vertex_to_faces = defaultdict(list)
            for face_idx, face in tqdm(enumerate(faces), position=0, desc="Finding adjacent faces"):
                for vertex in face:
                    vertex_to_faces[vertex].append(face_idx)
            
            # Calculate face centroids (these become the vertices of the hex tiles)
            face_centroids = []
            for face in tqdm(faces, position=0, desc="Calculating face centroids"):
                centroid = np.mean(vertices[face], axis=0)
                centroid /= np.linalg.norm(centroid)  # Project back to sphere
                face_centroids.append(centroid)
            face_centroids = np.array(face_centroids)
            
            # For each vertex in the original mesh, create a hex/pentagon
            # by ordering the centroids of adjacent faces
            hex_faces = []

            for vertex_idx in tqdm(range(len(vertices)), position=0, desc="Creating hex faces"):
                adjacent_faces = vertex_to_faces[vertex_idx]
                
                # Order the adjacent face centroids in circular order
                # We do this by sorting by angle around the vertex
                center = vertices[vertex_idx]
                
                # Create a local coordinate system
                # Use the first adjacent face centroid to define a reference direction
                ref_vec = face_centroids[adjacent_faces[0]] - center
                ref_vec /= np.linalg.norm(ref_vec)
                
                # Create perpendicular vector for angle calculation
                normal = center / np.linalg.norm(center)
                tangent = ref_vec - np.dot(ref_vec, normal) * normal
                tangent /= np.linalg.norm(tangent)
                bitangent = np.cross(normal, tangent)
                
                # Calculate angles for each adjacent face centroid
                angles = []
                for face_idx in adjacent_faces:
                    vec = face_centroids[face_idx] - center
                    vec /= np.linalg.norm(vec)
                    # Project onto tangent plane
                    vec_proj = vec - np.dot(vec, normal) * normal
                    vec_proj /= np.linalg.norm(vec_proj)
                    
                    # Calculate angle
                    x = np.dot(vec_proj, tangent)
                    y = np.dot(vec_proj, bitangent)
                    angle = np.arctan2(y, x)
                    angles.append((angle, face_idx))
                
                # Sort by angle
                angles.sort()
                ordered_faces = [face_idx for _, face_idx in angles]
                
                hex_faces.append(ordered_faces)
            
            return hex_faces, face_centroids

        # Create the cache directory if it doesn't exist
        os.makedirs('./.cache', exist_ok=True)

        # Check if cached tiles exist
        if self.use_cache:
            try:
                with open(f'./.cache/world_tiles_{rec_lvl}.pkl', 'rb') as f:
                    self.world_tiles = pickle.load(f)
                    print("\tLoaded cached world tiles.")
                    return
            except FileNotFoundError:
                print("\tNo cached world tiles found, generating new ones.")

        # Generate new tiles
        print("\tGenerating new world tiles...")
        start_time = time.time()
        vertices, faces = create_icosphere(rec_lvl)
        hex_faces, face_centroids = icosphere_to_hexsphere(vertices, faces)
        for hf in hex_faces:
            poly_verts = face_centroids[hf]
            self.world_tiles.append(WorldTile(np.mean(poly_verts, axis=0), poly_verts))
        print(f"\tTile generation took {time.time() - start_time:.2f} seconds.")

        # Convert 3D vertices to 2D (longitude, latitude)
        print("\tCalculating equirectangular coordinates for tiles...")
        start_time = time.time()
        for tile in tqdm(self.world_tiles, position=0, desc="Calculating equirectangular coordinates"):
            lon_lat = []
            for v in tile.vertices:
                x, y, z = v
                lon = np.arctan2(y, x)
                lat = np.arcsin(z / np.linalg.norm(v))
                lon_lat.append((lon, lat))

            # Unwrap longitudes to avoid stretching across the map edge
            lons = np.array([ll[0] for ll in lon_lat])
            lats = np.array([ll[1] for ll in lon_lat])
            # Find jumps in longitude
            lon_diffs = np.diff(lons)
            if np.any(np.abs(lon_diffs) > np.pi):
                # If a jump > pi is found, unwrap longitudes
                lons_unwrapped = lons.copy()
                for i in range(1, len(lons_unwrapped)):
                    diff = lons_unwrapped[i] - lons_unwrapped[i-1]
                    if diff > np.pi:
                        lons_unwrapped[i:] -= 2 * np.pi
                    elif diff < -np.pi:
                        lons_unwrapped[i:] += 2 * np.pi
                lon_lat = list(zip(lons_unwrapped, lats))
            tile.equirectangular_coords = lon_lat
        print(f"\tEquirectangular coordinate calculation took {time.time() - start_time:.2f} seconds.")


        # Save the world tiles to a file for faster loading next time
        with open(f'./.cache/world_tiles_{self.recursion_level}.pkl', 'wb') as f:
            pickle.dump(self.world_tiles, f)
        print("\tGenerated and cached new world tiles.")

    def populate_neighbor_lists(self):
        """
        Populate the neighbor lists for each tile.
        """
        # Create a mapping from vertex (as a tuple) to tiles that share it
        vertex_to_tiles = defaultdict(list)
        for tile in tqdm(self.world_tiles, position=0, desc="Mapping vertices to tiles"):
            for vertex in tile.vertices:
                vertex_key = tuple(np.round(vertex, decimals=6))  # Round to avoid floating point issues
                vertex_to_tiles[vertex_key].append(tile)

        # For each tile, find neighbors by looking up shared vertices
        for tile in tqdm(self.world_tiles, position=0, desc="Finding neighbors"):
            neighbor_set = set()
            for vertex in tile.vertices:
                vertex_key = tuple(np.round(vertex, decimals=6))
                for neighbor in vertex_to_tiles[vertex_key]:
                    if neighbor is not tile:
                        neighbor_set.add(neighbor)
            tile.neighbors = list(neighbor_set)


    """
    Basic terrain generation (using OpenSimplex noise)
    """
    def map_noise(self, scale, num_octaves):
        """
        Map 4D noise values to each tile for terrain generation.
        """
        noise_gen = opensimplex.OpenSimplex(seed=random.randint(0, 10000))
        for tile in tqdm(self.world_tiles, position=0, desc="Mapping noise"):
            x, y, z = tile.center
            # Scale coordinates for noise
            # Note: using 4D noise with a fixed w value to get a 3D slice for randomness
            value = 0

            for octave in range(num_octaves):
                frequency = 2 ** octave
                amplitude = 0.5 ** octave
                value += amplitude * noise_gen.noise4(x * scale * frequency, y * scale * frequency, z * scale * frequency, self.noise_4d_val)

            # noise value ranges from -1 to 1
            # Normalize to 0-1
            normalized_value = (value + 1) / 2

            tile.height = normalized_value


    """
    Tectonic plate generation and simulation
    """
    def create_tectonic_plates(self, num_plates):
        """
        Create tectonic plates by assigning tiles to plates.
        """
        loading_bar = tqdm(total=len(self.world_tiles), position=0, desc="Assigning tiles to tectonic plates")
        loading_bar.update(0)

        # Randomly select seed tiles for each plate
        seed_tiles = random.sample(self.world_tiles, num_plates)
        boundary_tiles = {} # key: plate_id, value: set of unassigned tiles bordering this plate
        boundary_plates = {} # key: a tile in boundary_tiles, value: set of plate_ids it borders

        # Assign each seed tile to a new plate
        plate_id = 0 # Unique ID for each plate
        for seed in seed_tiles:
            plate = TectonicPlate(plate_id, [seed])
            self.tectonic_plates.append(plate)
            seed.plate_id = plate_id
            plate_id += 1
            loading_bar.update(1)
        
        # Identify boundary tiles for each plate
        for plate in self.tectonic_plates:
            boundary_tiles[plate.plate_id] = set()
            for neighbor in plate.tiles[0].neighbors:
                print(neighbor)
                if neighbor.plate_id is None:
                    boundary_tiles[plate.plate_id].add(neighbor)
                    boundary_plates[neighbor] = boundary_plates.get(neighbor, set())
                    boundary_plates[neighbor].add(plate.plate_id)

        # Create a set of all bordering tiles
        all_bordering_tiles = set()
        for hex_set in boundary_tiles.values():
            all_bordering_tiles.update(hex_set)

        # Choose a random bordering tile and assign it to one of the plates it borders
        while all_bordering_tiles:
            chosen_tile = random.choice(list(all_bordering_tiles))
            bordering_plate_ids = boundary_plates[chosen_tile]
            assigned_plate_id = random.choice(list(bordering_plate_ids))

            # Assign tile to the chosen plate
            chosen_tile.plate_id = assigned_plate_id
            for plate in self.tectonic_plates:
                if plate.plate_id == assigned_plate_id:
                    plate.tiles.append(chosen_tile)
                    break
            # Remove from all_bordering_tiles
            all_bordering_tiles.remove(chosen_tile)

            # Update boundary tiles and boundary plates
            for neighbor in chosen_tile.neighbors:
                if neighbor.plate_id is None:
                    # Add to boundary tiles for the assigned plate
                    boundary_tiles[assigned_plate_id].add(neighbor)
                    # Update boundary plates mapping
                    boundary_plates[neighbor] = boundary_plates.get(neighbor, set())
                    boundary_plates[neighbor].add(assigned_plate_id)

            # Remove chosen_tile from boundary tiles of all plates
            for pid in bordering_plate_ids:
                if chosen_tile in boundary_tiles[pid]:
                    boundary_tiles[pid].remove(chosen_tile)
                    if not boundary_tiles[pid]:
                        del boundary_tiles[pid]

            # Rebuild all_bordering_tiles
            all_bordering_tiles = set()
            for hex_set in boundary_tiles.values():
                all_bordering_tiles.update(hex_set)

            loading_bar.update(1)

    def create_tectonic_plates_spherical_voronoi(self, num_plates, oceanic_plate_ratio):
        """
        Create tectonic plates using spherical Voronoi tessellation.
        """
        # Randomly select seed points on the sphere
        seed_points = []
        for _ in range(num_plates):
            phi = np.arccos(1 - 2 * random.random())  # polar angle
            theta = 2 * np.pi * random.random()       # azimuthal angle
            x = np.sin(phi) * np.cos(theta)
            y = np.sin(phi) * np.sin(theta)
            z = np.cos(phi)
            seed_points.append([x, y, z])
        seed_points = np.array(seed_points)

        # Create Spherical Voronoi tessellation
        sv = SphericalVoronoi(seed_points)
        sv.sort_vertices_of_regions()

        # Create TectonicPlate objects
        self.tectonic_plates = []
        for plate_id in range(num_plates):
            self.tectonic_plates.append(TectonicPlate(plate_id, []))

        # Assign tiles to plates based on closest seed point
        for tile in tqdm(self.world_tiles, position=0, desc="Assigning tiles to tectonic plates (Voronoi)"):
            min_dist = float('inf')
            assigned_plate_id = None
            for plate_id, center in enumerate(seed_points):
                dist = np.arccos(np.clip(np.dot(tile.center, center), -1.0, 1.0))
                if dist < min_dist:
                    min_dist = dist
                    assigned_plate_id = plate_id
            tile.plate_id = assigned_plate_id
            self.tectonic_plates[assigned_plate_id].tiles.append(tile)

        # Assign oceanic or continental plates based on ratio
        for plate in self.tectonic_plates:
            if random.random() < oceanic_plate_ratio:
                plate.plate_type = 'oceanic'
            else:
                plate.plate_type = 'continental'

        # Assign random movement vectors and rotation speeds
        for plate in self.tectonic_plates:
            # Random 2D movement vector tangent to sphere surface
            theta = random.uniform(0, 2 * np.pi)
            plate.movement_vector = np.array([np.cos(theta), np.sin(theta)])

            # Scale this vector to represent movement speed (e.g., cm/year)
            plate.movement_vector *= random.uniform(1, 10)  # cm/year

            # Random rotation speed between -1 and 1 degrees per million years
            plate.rotation_speed = random.uniform(-1, 1)

    def create_plate_boundaries(self):
        """
        Identify plate boundaries and create PlateBoundary objects.
        """
        boundary_dict = {}  # key: (plate1_id, plate2_id), value: list of boundary tiles

        for tile in tqdm(self.world_tiles, position=0, desc="Identifying plate boundaries"):
            for neighbor in tile.neighbors:
                if neighbor.plate_id != tile.plate_id:
                    plate_pair = tuple(sorted((tile.plate_id, neighbor.plate_id)))
                    if plate_pair not in boundary_dict:
                        boundary_dict[plate_pair] = set()
                    boundary_dict[plate_pair].add(tile)

        # Create PlateBoundary objects
        for (plate1_id, plate2_id), boundary_tiles in boundary_dict.items():
            plate1 = self.tectonic_plates[plate1_id]
            plate2 = self.tectonic_plates[plate2_id]

            # Determine boundary type and activity level TODO: test this logic
            if plate1.movement_vector is not None and plate2.movement_vector is not None:
                relative_movement = plate2.movement_vector - plate1.movement_vector
                movement_magnitude = np.linalg.norm(relative_movement)
                if movement_magnitude < 0.1:
                    boundary_type = 'transform'
                else:
                    # Check if plates are moving towards or away from each other
                    direction_dot = np.dot(plate1.movement_vector, plate2.movement_vector)
                    if direction_dot < 0:
                        boundary_type = 'convergent'
                    else:
                        boundary_type = 'divergent'
                activity_level = min(movement_magnitude / 10.0, 1.0)  # Normalize to [0, 1]

            boundary = PlateBoundary(plate1, plate2, list(boundary_tiles), boundary_type=boundary_type, activity_level=activity_level)
            self.plate_boundaries.append(boundary)
            plate1.boundaries.append(boundary)
            plate2.boundaries.append(boundary)

    def assign_heights_using_plates(self, continental_height, oceanic_height):
        """
        Simulate tectonic activity!
        """

        for tile in self.world_tiles:
            if tile.plate_id is None:
                raise ValueError("Tile has no assigned plate. Call create_tectonic_plates() first.")

            # Assign base heights based on plate type
            plate = self.tectonic_plates[tile.plate_id]
            if plate.plate_type == 'continental':
                tile.height = continental_height
            else:
                tile.height = oceanic_height

        # Adjust heights at plate boundaries
        for boundary in self.plate_boundaries:
            for tile in boundary.direct_boundary_tiles:
                if boundary.boundary_type == 'convergent':
                    # Raise height for convergent boundaries
                    tile.height += 0.1 * boundary.activity_level
                elif boundary.boundary_type == 'divergent':
                    # Lower height for divergent boundaries
                    tile.height -= 0.1 * boundary.activity_level
                # Transform boundaries have no height change

                # # Clamp height to [0, 1]
                # tile.height = max(0.0, min(1.0, tile.height)))


    """
    Tile coloring
    """
    def assign_terrain_colors_by_height(self, water_threshold=0.5, beach_threshold=0.52, land_threshold=0.73, mountain_threshold=0.81, water_low_color=(0, 0, 0.2), water_high_color=(0, 0, 1), beach_color=(0.86, 0.80, 0.20), land_low_color=(0, 0.4, 0), land_high_color=(0, 1, 0), mountain_low_color=(0.7, 0.7, 0.7), mountain_high_color=(0.8, 0.8, 0.8), snow_color=(1, 1, 1)):
        """
        Assign terrain colors to each tile based on height values.
        """
        for tile in self.world_tiles:
            if tile.height is None:
                raise ValueError("Height values not mapped. Call map_noise() or assign height values using another function first.")
            if tile.height < water_threshold:
                # Blue value should move from water_low_color to water_high_color based on hexagon.height
                t = tile.height / water_threshold
                tile.color = tuple(np.array(water_low_color) * (1 - t) + np.array(water_high_color) * t)
            elif tile.height < beach_threshold:
                tile.color = beach_color
            elif tile.height < land_threshold:
                # Green value should move from land_low_color to land_high_color based on hexagon.height
                t = (tile.height - water_threshold) / (land_threshold - water_threshold)
                tile.color = tuple(np.array(land_low_color) * (1 - t) + np.array(land_high_color) * t)
            elif tile.height < mountain_threshold:
                # Gray value should move from mountain_low_color to mountain_high_color based on hexagon.height
                t = (tile.height - land_threshold) / (mountain_threshold - land_threshold)
                tile.color = tuple(np.array(mountain_low_color) * (1 - t) + np.array(mountain_high_color) * t)
            else:
                # White color for snow
                tile.color = snow_color

    def assign_tectonic_plate_colors(self):
        """
        Assign colors to tiles based on their tectonic plate.
        """
        plate_colors = {}
        for plate in self.tectonic_plates:
            # Assign a random color to each plate
            plate_colors[plate.plate_id] = (random.random(), random.random(), random.random())

        for tile in self.world_tiles:
            if tile.plate_id is not None:
                tile.color = plate_colors[tile.plate_id]
            else:
                tile.color = (0.5, 0.5, 0.5)  # Gray for unassigned tiles


    """
    Visualization
    """
    def plot_equirectangular(self):
        # Simple equirectangular projection for testing
        fig, ax = plt.subplots(figsize=(10, 5))
        for tile in self.world_tiles:
            polygon = plt.Polygon(tile.equirectangular_coords, edgecolor=None, alpha=0.5, facecolor=tile.color)
            ax.add_patch(polygon)

        ax.set_xlim(-np.pi - 0.3, np.pi + 0.3) # Add some padding for longitudes that were unwrapped
        ax.set_ylim(-np.pi/2, np.pi/2)
        ax.set_aspect('equal')
        plt.show()

    def plot_sphere(self):
        """
        Visualize the hexagon and pentagon-tiled sphere.
        """
        fig = plt.figure(figsize=(5, 5))
        
        # Hex-tiled sphere
        ax = fig.add_subplot(projection='3d')
        hex_polys = []
        colors = []
        for tile in self.world_tiles:
            poly_verts = tile.vertices
            hex_polys.append(poly_verts)
            colors.append(tile.color)

        poly = Poly3DCollection(hex_polys, facecolors=colors, linewidths=1, edgecolors='black', alpha=0.9)
        ax.add_collection3d(poly)
        
        max_range = 1.2
        ax.set_xlim(-max_range, max_range)
        ax.set_ylim(-max_range, max_range)
        ax.set_zlim(-max_range, max_range)
        ax.set_box_aspect([1, 1, 1])
        
        plt.tight_layout()
        plt.show()

    def plot_sphere_vispy(self, visualize_heights=False, height_scale=0.1, shading=True):
        from vispy import app, scene
        from vispy.visuals.filters import ShadingFilter, WireframeFilter

        print(app.use_app())

        # Create VisPy canvas with 3D camera
        canvas = scene.SceneCanvas(keys='interactive', show=True, bgcolor='white')
        view = canvas.central_widget.add_view()
        view.camera = scene.cameras.TurntableCamera(fov=45, distance=10)

        colorset = set()
        for tile in self.world_tiles:
            colorset.add(tile.color)
        print(f"Unique colors used: {len(colorset)}")

        all_faces = []
        all_verts = []
        all_face_colors = []
        vert_offset = 0

        if visualize_heights:
            extra_verts = []
            extra_faces = []
            extra_colors = []
            extra_vert_offset = 0

        for tile in self.world_tiles:
            if visualize_heights:
                # set the center vertex to be offset by height
                normal_vec = tile.center / np.linalg.norm(tile.center)
                center_vertex = tile.center + normal_vec * (tile.height * height_scale)

                # numpy has a bug where after being pickled, numpy.ndarray's isbuiltin is set to 0
                # this fixes that issue
                equi_type = getattr(np, str(tile.vertices.dtype))
                tile.vertices = tile.vertices.astype(equi_type)

                hex_verts = tile.vertices.copy()
                for v_idx in range(len(hex_verts)):
                    normal_vec = hex_verts[v_idx] / np.linalg.norm(hex_verts[v_idx])
                    hex_verts[v_idx] = hex_verts[v_idx] + normal_vec * (tile.height * height_scale)
                these_verts = np.vstack([center_vertex, hex_verts])

                # Add 2 new faces for every edge: connecting the original cordinates to the heighted coordinates
                num_vertices = len(tile.vertices)
                for i in range(num_vertices):
                    v1_base = tile.vertices[i]
                    v2_base = tile.vertices[(i + 1) % num_vertices]
                    v1_height = hex_verts[i]
                    v2_height = hex_verts[(i + 1) % num_vertices]

                    extra_verts.extend([v1_base, v2_base, v2_height, v1_height])
                    extra_faces.append([
                        extra_vert_offset,
                        extra_vert_offset + 1,
                        extra_vert_offset + 2,
                    ])
                    extra_faces.append([
                        extra_vert_offset,
                        extra_vert_offset + 2,
                        extra_vert_offset + 3,
                    ])
                    extra_vert_offset += 4
                
                extra_colors.append([tile.color] * (num_vertices * 2))

            else:
                these_verts = np.vstack([tile.center, tile.vertices])

            if len(tile.vertices) == 5:
                # Pentagons need to be triangulated
                faces = np.array([
                    [0, 1, 2],
                    [0, 2, 3],
                    [0, 3, 4],
                    [0, 4, 5],
                    [0, 5, 1],
                ])
            else:
                # Hexagons can be triangulated similarly
                faces = np.array([
                    [0, 1, 2],
                    [0, 2, 3],
                    [0, 3, 4],
                    [0, 4, 5],
                    [0, 5, 6],
                    [0, 6, 1],
                ])

            all_verts.append(these_verts)
            all_faces.append(faces + vert_offset)
            all_face_colors.append([tile.color] * faces.shape[0])
            vert_offset += these_verts.shape[0]

        mesh = scene.visuals.Mesh(vertices=np.concatenate(all_verts), faces=np.concatenate(all_faces), face_colors=np.concatenate(all_face_colors), shading=None)
        view.add(mesh)
        if visualize_heights:
            extra_mesh = scene.visuals.Mesh(vertices=np.array(extra_verts), faces=np.array(extra_faces), face_colors=np.concatenate(extra_colors), shading=None)
            view.add(extra_mesh)

        if shading:
            global shading_state_index
            global wireframe_state_index
            global shininess_state_index

            # Use filters to affect the rendering of the mesh.
            wireframe_filter = WireframeFilter(enabled=False)
            # Note: For convenience, this `ShadingFilter` would be created automatically by
            # the `MeshVisual with, e.g. `mesh = MeshVisual(..., shading='smooth')`. It is
            # created manually here for demonstration purposes.
            shading_filter = ShadingFilter(shading='smooth', shininess=1000)
            # The wireframe filter is attached before the shading filter otherwise the
            # wireframe is not shaded.
            mesh.attach(wireframe_filter)
            mesh.attach(shading_filter)

            if visualize_heights:
                extra_wireframe_filter = WireframeFilter(enabled=False)
                extra_shading_filter = ShadingFilter(shading='smooth', shininess=1000)
                extra_mesh.attach(extra_wireframe_filter)
                extra_mesh.attach(extra_shading_filter)

            def attach_headlight(view):
                light_dir = (0, 1, 0, 0)
                shading_filter.light_dir = light_dir[:3]
                initial_light_dir = view.camera.transform.imap(light_dir)

                @view.scene.transform.changed.connect
                def on_transform_change(event):
                    transform = view.camera.transform
                    shading_filter.light_dir = transform.map(initial_light_dir)[:3]


            attach_headlight(view)

            shading_states = (
                dict(shading=None),
                dict(shading='flat'),
                dict(shading='smooth'),
            )
            shading_state_index = shading_states.index(
                dict(shading=shading_filter.shading))

            wireframe_states = (
                dict(wireframe_only=False, faces_only=False,),
                dict(wireframe_only=True, faces_only=False,),
                dict(wireframe_only=False, faces_only=True,),
            )
            wireframe_state_index = wireframe_states.index(dict(
                wireframe_only=wireframe_filter.wireframe_only,
                faces_only=wireframe_filter.faces_only,
            ))

            shininess_states = (1, 10, 100, 1000)
            shininess_state_index = 3

            def cycle_state(states, index):
                new_index = (index + 1) % len(states)
                return states[new_index], new_index


            @canvas.events.key_press.connect
            def on_key_press(event):
                global shading_state_index
                global wireframe_state_index
                global shininess_state_index
                if event.key == 's':
                    state, shading_state_index = cycle_state(shading_states,
                                                            shading_state_index)
                    for attr, value in state.items():
                        setattr(shading_filter, attr, value)
                        if visualize_heights:
                            setattr(extra_shading_filter, attr, value)
                    mesh.update()
                    if visualize_heights:
                        extra_mesh.update()
                elif event.key == 'w':
                    wireframe_filter.enabled = not wireframe_filter.enabled
                    if visualize_heights:
                        extra_wireframe_filter.enabled = not extra_wireframe_filter.enabled
                    mesh.update()
                    if visualize_heights:
                        extra_mesh.update()
                elif event.key == 'f':
                    state, wireframe_state_index = cycle_state(wireframe_states,
                                                            wireframe_state_index)
                    for attr, value in state.items():
                        setattr(wireframe_filter, attr, value)
                        if visualize_heights:
                            setattr(extra_wireframe_filter, attr, value)
                    mesh.update()
                    if visualize_heights:
                        extra_mesh.update()
                elif event.key == 'h':
                    state, shininess_state_index = cycle_state(
                        shininess_states, shininess_state_index)
                    shading_filter.shininess = state
                    if visualize_heights:
                        extra_shading_filter.shininess = state
                    mesh.update()
                    if visualize_heights:
                        extra_mesh.update()
            
        app.run()
        
    """Testing and debugging"""
    def print_geometry_statistics(self):
        """
        Print statistics about the hexagonal grid.
        """
        num_tiles = len(self.world_tiles)
        num_pentagons = sum(1 for t in self.world_tiles if len(t.vertices) == 5)
        num_hexagons = num_tiles - num_pentagons

        max_x_coord_for_center_of_tile = max(t.center[0] for t in self.world_tiles)
        min_x_coord_for_center_of_tile = min(t.center[0] for t in self.world_tiles)
        max_y_coord_for_center_of_tile = max(t.center[1] for t in self.world_tiles)
        min_y_coord_for_center_of_tile = min(t.center[1] for t in self.world_tiles)
        max_z_coord_for_center_of_tile = max(t.center[2] for t in self.world_tiles)
        min_z_coord_for_center_of_tile = min(t.center[2] for t in self.world_tiles)

        print(f"Total tiles (including pentagons): {num_tiles}")
        print(f"Number of pentagons: {num_pentagons}")
        print(f"Number of hexagons: {num_hexagons}")
        print(f"Max X coord for center of tile: {max_x_coord_for_center_of_tile}")
        print(f"Min X coord for center of tile: {min_x_coord_for_center_of_tile}")
        print(f"Max Y coord for center of tile: {max_y_coord_for_center_of_tile}")
        print(f"Min Y coord for center of tile: {min_y_coord_for_center_of_tile}")
        print(f"Max Z coord for center of tile: {max_z_coord_for_center_of_tile}")
        print(f"Min Z coord for center of tile: {min_z_coord_for_center_of_tile}")

    def paint_random_and_neighbors_red(self):
        """
        For testing: Paint a random tile and its neighbors red.
        """
        random_hex = random.choice(self.world_tiles)
        random_hex.color = (1.0, 0, 0)  # Red
        for neighbor in random_hex.neighbors:
            neighbor.color = (1.0, 0, 0)  # Red

    def make_random_tower(self, height_increase=0.5):
        """
        For testing: Increase the height of a random tile to create a tower.
        """
        random_hex = random.choice(self.world_tiles)
        random_hex.height += height_increase
        # Clamp height to [0, 1]
        random_hex.height = max(0.0, min(1.0, random_hex.height))

class TectonicPlate:
    """
    Represents a tectonic plate consisting of multiple WorldTiles.
    """
    def __init__(self, plate_id, tiles):
        self.plate_id = plate_id
        self.tiles = tiles  # List of WorldTile objects belonging to this plate
        self.plate_type = None  # 'oceanic' or 'continental', assigned later
        self.movement_vector = None  # 2D vector (tangent to sphere surface), assigned later
        self.rotation_speed = None  # positive values: clockwise, positive: counter-clockwise (as viewed from above), assigned later
        self.boundaries = []  # List of PlateBoundary objects
        # self.noise_4d_val = np.random.uniform(0, 1000)  # Random value for 4D noise slice. Used for noise within the plate

class PlateBoundary:
    """
    Represents a boundary between two tectonic plates.
    """
    def __init__(self, plate1, plate2, boundary_tiles, boundary_type, activity_level):
        self.plate1 = plate1  # TectonicPlate object
        self.plate2 = plate2  # TectonicPlate object
        self.direct_boundary_tiles = boundary_tiles  # List of WorldTile objects along the boundary
        self.boundary_type = boundary_type  # 'convergent', 'divergent', 'transform', assigned later
        self.activity_level = activity_level  # [0,1) the intensity of the boundary activity: e.g. convergent boundaries with high activity_level have taller mountains

class WorldTile:
    """
    Represents a tile on the sphere (hexagon or pentagon).
    """


    """
    Standard functions
    """
    def __init__(self, center, vertices):
        self.center = center  # 3D coordinates on the sphere [x, y, z]
        self.vertices = vertices  # List of 3D vertex coordinates [[x, y, z], ...]
        self.height = None  # Value assigned later
        self.color = None  # RGB tuple with values 0-1, assigned later
        self.equirectangular_coords = None  # List of (lon, lat) tuples for 2D mapping, assigned later
        self.neighbors = []  # List of neighboring WorldTiles
        self.plate_id = None  # Assigned later for tectonic plates

    def __repr__(self):
        return f"WorldTile(center={self.center}, num_vertices={len(self.vertices)}, height={self.height}, plate_id={self.plate_id})"


"""
Main execution
"""
def main():
    print("Creating simulated globe...")
    start_time = time.time()
    globe = SimulatedGlobe(recursion_level=7, use_cache=True)
    end_time = time.time()
    print(f"Globe creation took {end_time - start_time:.2f} seconds.")

    print("Mapping noise...")
    start_time = time.time()
    globe.map_noise(scale=2.0, num_octaves=4)
    end_time = time.time()
    print(f"Noise mapping took {end_time - start_time:.2f} seconds.")

    print("Populating neighbor lists...")
    start_time = time.time()
    globe.populate_neighbor_lists()
    end_time = time.time()
    print(f"Neighbor list population took {end_time - start_time:.2f} seconds.")

    # print("Assigning tectonic plates...")
    # start_time = time.time()
    # globe.create_tectonic_plates_spherical_voronoi(num_plates=NUM_TECTONIC_PLATES, oceanic_plate_ratio=OCEANIC_PLATE_RATIO)
    # end_time = time.time()
    # print(f"Tectonic plate assignment took {end_time - start_time:.2f} seconds.")

    # print("Creating plate boundaries...")
    # start_time = time.time()
    # globe.create_plate_boundaries()
    # end_time = time.time()
    # print(f"Plate boundary creation took {end_time - start_time:.2f} seconds.")

    # print("Assigning heights based on tectonic plates...")
    # start_time = time.time()
    # globe.assign_heights_using_plates(continental_height=CONTINENTAL_PLATE_AVG_HEIGHT, oceanic_height=OCEANIC_PLATE_AVG_HEIGHT)
    # end_time = time.time()
    # print(f"Height assignment took {end_time - start_time:.2f} seconds.")

    # print("Assigning tectonic plate colors...")
    # start_time = time.time()
    # globe.assign_tectonic_plate_colors()
    # end_time = time.time()
    # print(f"Tectonic plate color assignment took {end_time - start_time:.2f} seconds.")

    print("Assigning terrain colors based on height...")
    start_time = time.time()
    globe.assign_terrain_colors_by_height(
        water_threshold=WATER_THRESHOLD,
        beach_threshold=BEACH_THRESHOLD,
        land_threshold=LAND_THRESHOLD,
        mountain_threshold=MOUNTAIN_THRESHOLD,
        water_low_color=WATER_LOW_COLOR,
        water_high_color=WATER_HIGH_COLOR,
        beach_color=BEACH_COLOR,
        land_low_color=LAND_LOW_COLOR,
        land_high_color=LAND_HIGH_COLOR,
        mountain_low_color=MOUNTAIN_LOW_COLOR,
        mountain_high_color=MOUNTAIN_HIGH_COLOR,
        snow_color=SNOW_COLOR,
    )
    end_time = time.time()
    print(f"Height-based color assignment took {end_time - start_time:.2f} seconds.")

    # print("Painting a random tile and its neighbors red...")
    # start_time = time.time()
    # globe.paint_random_and_neighbors_red()  # For testing neighbor functionality
    # end_time = time.time()
    # print(f"Painting took {end_time - start_time:.2f} seconds.")

    # print("Printing geometry statistics...")
    # start_time = time.time()
    # globe.print_geometry_statistics()
    # end_time = time.time()
    # print(f"Geometry statistics took {end_time - start_time:.2f} seconds.")

    # print("Plotting the globe...")
    # globe.plot_sphere()
    # end_time = time.time()
    # print(f"Globe plotting took {end_time - start_time:.2f} seconds.")

    print("Plotting with VisPy...")
    start_time = time.time()
    globe.plot_sphere_vispy(visualize_heights=True, height_scale=0.1)
    end_time = time.time()
    print(f"VisPy plotting took {end_time - start_time:.2f} seconds.")

    # print("Plotting equirectangular projection...")
    # start_time = time.time()
    # globe.plot_equirectangular()
    # end_time = time.time()
    # print(f"Equirectangular projection plotting took {end_time - start_time:.2f} seconds.")

if __name__ == '__main__':
    main()